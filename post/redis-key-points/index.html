<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Redis八股文背诵版 - Rogee's 备忘录</title>
<meta name=renderer content="webkit">
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<meta http-equiv=cache-control content="no-transform">
<meta http-equiv=cache-control content="no-siteapp">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=author content="Rogee"><meta name=description content="Redis单线程原理 首先必须明确，Redis单线程指的是网络请求模块使用了一个线程（，其他模块仍用了多个线程。并不是一个线程完成了所有功能。原理上，其采用了利用epoll的多路复用特性，因此可以采用单线程处理其网络请求。
Redis数据类型 String：字符串类型，最简单的类型 Hash：类似于Map的一种结构。List：有序列表。Set:无序集合。ZSet：带权值的无序集合，即每个ZSet元素还另有一个数字代表权值，集合通过权值进行排序。
"><meta name=keywords content="备忘录,Rogee,烂笔头">
<meta name=generator content="Hugo 0.89.4 with theme even">
<link rel=canonical href=http://notes.711xd.com/post/redis-key-points/>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=manifest href=/manifest.json>
<link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous>
<meta property="og:title" content="Redis八股文背诵版">
<meta property="og:description" content="Redis单线程原理
首先必须明确，Redis单线程指的是网络请求模块使用了一个线程（，其他模块仍用了多个线程。并不是一个线程完成了所有功能。原理上，其采用了利用epoll的多路复用特性，因此可以采用单线程处理其网络请求。
Redis数据类型
String：字符串类型，最简单的类型 Hash：类似于Map的一种结构。List：有序列表。Set:无序集合。ZSet：带权值的无序集合，即每个ZSet元素还另有一个数字代表权值，集合通过权值进行排序。">
<meta property="og:type" content="article">
<meta property="og:url" content="http://notes.711xd.com/post/redis-key-points/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2021-11-26T16:29:46+08:00">
<meta property="article:modified_time" content="2021-11-26T16:31:21+08:00">
<meta itemprop=name content="Redis八股文背诵版">
<meta itemprop=description content="Redis单线程原理
首先必须明确，Redis单线程指的是网络请求模块使用了一个线程（，其他模块仍用了多个线程。并不是一个线程完成了所有功能。原理上，其采用了利用epoll的多路复用特性，因此可以采用单线程处理其网络请求。
Redis数据类型
String：字符串类型，最简单的类型 Hash：类似于Map的一种结构。List：有序列表。Set:无序集合。ZSet：带权值的无序集合，即每个ZSet元素还另有一个数字代表权值，集合通过权值进行排序。"><meta itemprop=datePublished content="2021-11-26T16:29:46+08:00">
<meta itemprop=dateModified content="2021-11-26T16:31:21+08:00">
<meta itemprop=wordCount content="2253">
<meta itemprop=keywords content="Redis,面试,"><meta name=twitter:card content="summary">
<meta name=twitter:title content="Redis八股文背诵版">
<meta name=twitter:description content="Redis单线程原理
首先必须明确，Redis单线程指的是网络请求模块使用了一个线程（，其他模块仍用了多个线程。并不是一个线程完成了所有功能。原理上，其采用了利用epoll的多路复用特性，因此可以采用单线程处理其网络请求。
Redis数据类型
String：字符串类型，最简单的类型 Hash：类似于Map的一种结构。List：有序列表。Set:无序集合。ZSet：带权值的无序集合，即每个ZSet元素还另有一个数字代表权值，集合通过权值进行排序。"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>Rogee's 备忘录</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<a href=/>
<li class=mobile-menu-item>首页</li>
</a><a href=/post/>
<li class=mobile-menu-item>归档</li>
</a><a href=/tags/>
<li class=mobile-menu-item>标签</li>
</a><a href=/categories/>
<li class=mobile-menu-item>分类</li>
</a><a href=/about/>
<li class=mobile-menu-item>关于</li>
</a>
</ul>
</nav>
<div class=container id=mobile-panel>
<header id=header class=header>
<div class=logo-wrapper>
<a href=/ class=logo>Rogee's 备忘录</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=/>首页</a>
</li><li class=menu-item>
<a class=menu-item-link href=/post/>归档</a>
</li><li class=menu-item>
<a class=menu-item-link href=/tags/>标签</a>
</li><li class=menu-item>
<a class=menu-item-link href=/categories/>分类</a>
</li><li class=menu-item>
<a class=menu-item-link href=/about/>关于</a>
</li>
</ul>
</nav>
</header>
<main id=main class=main>
<div class=content-wrapper>
<div id=content class=content>
<article class=post>
<header class=post-header>
<h1 class=post-title>Redis八股文背诵版</h1>
<div class=post-meta>
<span class=post-time> 2021-11-26 </span>
<span id=busuanzi_container_page_pv class=more-meta> <span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次阅读 </span>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>文章目录</h2>
<div class=post-toc-content>
<nav id=TableOfContents>
<ul>
<li>
<ul>
<li><a href=#redis单线程原理><strong>Redis单线程原理</strong></a></li>
<li><a href=#redis数据类型><strong>Redis数据类型</strong></a></li>
<li><a href=#什么情况下使用redis><strong>什么情况下使用redis</strong></a></li>
<li><a href=#redis与memcache的区别><strong>redis与memcache的区别</strong></a></li>
<li><a href=#简述缓存穿透><strong>简述缓存穿透</strong></a></li>
<li><a href=#简述缓存穿透的解决方法><strong>简述缓存穿透的解决方法</strong></a></li>
<li><a href=#简述缓存击穿><strong>简述缓存击穿</strong></a></li>
<li><a href=#简述缓存穿透的解决方法-1><strong>简述缓存穿透的解决方法</strong></a></li>
<li><a href=#简述缓存雪崩><strong>简述缓存雪崩</strong></a></li>
<li><a href=#简述缓存雪崩的解决方法><strong>简述缓存雪崩的解决方法</strong></a></li>
<li><a href=#redis有哪些集群部署方式><strong>Redis有哪些集群部署方式</strong></a></li>
<li><a href=#简述主从复制模式><strong>简述主从复制模式</strong></a></li>
<li><a href=#简述哨兵模式><strong>简述哨兵模式</strong></a></li>
<li><a href=#cluster集群><strong>cluster集群</strong></a></li>
<li><a href=#简述redis的rdb><strong>简述Redis的RDB</strong></a></li>
<li><a href=#简述redis的save命令><strong>简述Redis的save命令</strong></a></li>
<li><a href=#简述redis的bgsave命令><strong>简述Redis的bgsave命令</strong></a></li>
<li><a href=#简述redis自动触发rdb机制><strong>简述Redis自动触发RDB机制</strong></a></li>
<li><a href=#简述redis的aof><strong>简述Redis的AOF</strong></a></li>
<li><a href=#简述aof的持久化策略><strong>简述AOF的持久化策略</strong></a></li>
<li><a href=#简述aof的重写><strong>简述AOF的重写</strong></a></li>
<li><a href=#rdb与aof优缺点比较><strong>RDB与AOF优缺点比较</strong></a></li>
</ul>
</li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<h2 id=redis单线程原理><strong>Redis单线程原理</strong></h2>
<p>首先必须明确，Redis单线程指的是网络请求模块使用了一个线程（，其他模块仍用了多个线程。并不是一个线程完成了所有功能。原理上，其采用了利用epoll的多路复用特性，因此可以采用单线程处理其网络请求。</p>
<h2 id=redis数据类型><strong>Redis数据类型</strong></h2>
<p>String：字符串类型，最简单的类型 Hash：类似于Map的一种结构。List：有序列表。Set:无序集合。ZSet：带权值的无序集合，即每个ZSet元素还另有一个数字代表权值，集合通过权值进行排序。</p>
<h2 id=什么情况下使用redis><strong>什么情况下使用redis</strong></h2>
<ol>
<li>
<p>针对热点数据进行缓存</p>
</li>
<li>
<p>对于特定限时数据的存放</p>
</li>
<li>
<p>针对带热点权值数据的排序list</p>
</li>
<li>
<p>分布式锁</p>
</li>
</ol>
<h2 id=redis与memcache的区别><strong>redis与memcache的区别</strong></h2>
<ol>
<li>
<p>redis处理网络请求采用单线程模型，而memcache采用多线程异步IO的方式</p>
</li>
<li>
<p>redis支持数据持久化，memcache不支持</p>
</li>
<li>
<p>redis支持的数据格式比memcache更多</p>
</li>
</ol>
<h2 id=简述缓存穿透><strong>简述缓存穿透</strong></h2>
<p>缓存穿透指缓存和数据库均没有需要查询的数据，攻击者不断发送这种请求，使数据库压力过大。</p>
<h2 id=简述缓存穿透的解决方法><strong>简述缓存穿透的解决方法</strong></h2>
<ol>
<li>
<p>在数据库操作访问前进行校验，对不合法请求直接返回。</p>
</li>
<li>
<p>对于经常被访问的，并且数据库没有的键，缓存层记录键=null。</p>
</li>
</ol>
<h2 id=简述缓存击穿><strong>简述缓存击穿</strong></h2>
<p>缓存击穿指缓存中没有数据，但数据库中有该数据。一般这种情况指特定数据的缓存时间到期，但由于并发用户访问该数据特别多，因此去数据库去取数据，引起数据库访问压力过大</p>
<h2 id=简述缓存穿透的解决方法-1><strong>简述缓存穿透的解决方法</strong></h2>
<ol>
<li>
<p>设置热点数据永远不过期。</p>
</li>
<li>
<p>对并发读数据设置并发锁，降低并发性</p>
</li>
</ol>
<h2 id=简述缓存雪崩><strong>简述缓存雪崩</strong></h2>
<p>缓存雪崩指缓存中一大批数据到过期时间，而从缓存中删除。但该批数据查询数据量巨大，查询全部走数据库，造成数据库压力过大。</p>
<h2 id=简述缓存雪崩的解决方法><strong>简述缓存雪崩的解决方法</strong></h2>
<ol>
<li>
<p>缓存数据设置随机过期时间，防止同一时间大量数据过期。</p>
</li>
<li>
<p>设置热点数据永远不过期。</p>
</li>
<li>
<p>对于集群部署的情况，将热点数据均与分布在不同缓存中。</p>
</li>
</ol>
<h2 id=redis有哪些集群部署方式><strong>Redis有哪些集群部署方式</strong></h2>
<ol>
<li>
<p>主从复制</p>
</li>
<li>
<p>哨兵模式</p>
</li>
<li>
<p>Cluster集群模式</p>
</li>
</ol>
<h2 id=简述主从复制模式><strong>简述主从复制模式</strong></h2>
<p>在主从复制中，有主库（Master）节点和从库（Slave）节点两个角色。从节点服务启动会连接主库，并向主库发送SYNC命令。</p>
<p>主节点收到同步命令，启动持久化工作，工作执行完成后，主节点将传送整个数据库文件到从库，从节点接收到数据库文件数据之后将数据进行加载。此后，主节点继续将所有已经收集到的修改命令，和新的修改命令依次传送给从节点，从节点依次执行，从而达到最终的数据同步。</p>
<p>通过这种方式，可以使写操作作用于主库，而读操作作用于从库，从而达到读写分离。</p>
<h2 id=简述哨兵模式><strong>简述哨兵模式</strong></h2>
<p>哨兵模式监控redis集群中Master的工作的状态。在Master主服务器宕机时，从slave中选择新机器当作master，保证系统高可用。</p>
<p>每个哨兵每10秒向主服务器，slave和其他哨兵发送ping。</p>
<p>客户端通过哨兵，由哨兵提供可供服务的redis master节点。</p>
<p>哨兵只需要配master节点，会自动寻找其对应的slave节点。</p>
<p>监控同一master节点的哨兵会自动互联，组成哨兵网络，当任一哨兵发现master连接不上，即开会投票，投票半数以上决定Master下线，并从slave节点中选取master节点。</p>
<h2 id=cluster集群><strong>cluster集群</strong></h2>
<p>cluster提出了虚拟槽的概念。</p>
<ol>
<li>
<p>redis cluster默认有16384个槽，在集群搭建的时候，需要给节点分配哈希槽尽可能相同数量虚拟槽。</p>
</li>
<li>
<p>如果目前redis执行set操作，redis先对这个key经过CRC16 hash运算，并把结果对16384取余，得到槽编号。</p>
</li>
<li>
<p>根据槽编号，寻找到其对应的redis节点，在节点上执行hash命令。</p>
</li>
<li>
<p>如果此时执行get操作，节点先验证该key对应的槽编号是不是归本节点管，如果是则保存数据。如果不是，则发送正确节点编号给客户端。</p>
</li>
</ol>
<h2 id=简述redis的rdb><strong>简述Redis的RDB</strong></h2>
<p>RDB即将当前数据生成快照，并保存于硬盘中。可以通过手动命令，也可以设置自动触发。</p>
<h2 id=简述redis的save命令><strong>简述Redis的save命令</strong></h2>
<p>save命令是redis手动触发RDB过程的命令。使用该命令后，服务器阻塞，直到RDB过程完成后终止。该过程占用内存较多。</p>
<h2 id=简述redis的bgsave命令><strong>简述Redis的bgsave命令</strong></h2>
<p>bgsave命令不阻塞主进程（严格意义上也不是完全不阻塞，详看下面过程），该命令fork一个子进程用于执行RDB过程。其具体过程为：</p>
<ol>
<li>
<p>判断此时有没有子进程用于RDB，有的话直接返回。</p>
</li>
<li>
<p>redis进行fork子进程过程，此时父进程处于阻塞状态。</p>
</li>
<li>
<p>子进程创建RDB文件，完成后返回给父进程</p>
</li>
</ol>
<h2 id=简述redis自动触发rdb机制><strong>简述Redis自动触发RDB机制</strong></h2>
<ol>
<li>
<p>通过配置文件，设置一定时间后自动执行RDB</p>
</li>
<li>
<p>如采用主从复制过程，会自动执行RDB</p>
</li>
<li>
<p>Redis执行shutdown时，在未开启AOF后会执行RDB</p>
</li>
</ol>
<h2 id=简述redis的aof><strong>简述Redis的AOF</strong></h2>
<p>AOF通过日志，对数据的写入修改操作进行记录。这种持久化方式实时性更好。通过配置文件打开AOF。</p>
<h2 id=简述aof的持久化策略><strong>简述AOF的持久化策略</strong></h2>
<ol>
<li>
<p>always。每执行一次数据修改命令就将其命令写入到磁盘日志文件上。</p>
</li>
<li>
<p>everysec。每秒将命令写入到磁盘日志文件上。</p>
</li>
<li>
<p>no。不主动设置，由操作系统决定什么时候写入到磁盘日志文件上。</p>
</li>
</ol>
<h2 id=简述aof的重写><strong>简述AOF的重写</strong></h2>
<p>随着客户端不断进行操作，AOF对应的文件也越来越大。redis提供了bgrewriteaof函数，针对目前数据库中数据，在不读取原有AOF文件的基础上，重写了一个新的AOF文件，减少文件大小。</p>
<h2 id=rdb与aof优缺点比较><strong>RDB与AOF优缺点比较</strong></h2>
<p>AOF占用的文件体积比RDB大。一般来说利用AOF备份对系统的消耗比RDB低。对于备份时出现系统故障，RDB数据可能会全丢，但AOF只会损失一部分。RDB恢复速度比AOF低。</p>
</div>
<div class=post-copyright>
<p class=copyright-item>
<span class=item-title>文章作者</span>
<span class=item-content>Rogee</span>
</p>
<p class=copyright-item>
<span class=item-title>上次更新</span>
<span class=item-content>
2021-11-26
<a href=https://github.com/rogeecn/notes/commit/8dc87a73a3f2da82883c4dc2f9a7d61a70e53f9a title=post>(8dc87a7)</a>
</span>
</p>
</div>
<footer class=post-footer>
<div class=post-tags>
<a href=/tags/redis/>Redis</a>
<a href=/tags/%E9%9D%A2%E8%AF%95/>面试</a>
</div>
<nav class=post-nav>
<a class=prev href=/post/apisix-https-sni-error/>
<i class="iconfont icon-left"></i>
<span class="prev-text nav-default">Apisix 配置 HTTPS SNI 不识别问题定位</span>
<span class="prev-text nav-mobile">上一篇</span>
</a>
<a class=next href=/post/golang-float-byte-convert/>
<span class="next-text nav-default">golang float32/64与[]byte互转</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i>
</a>
</nav>
</footer>
</article>
</div>
<div id=gitalk-container></div>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css crossorigin=anonymous>
<script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js crossorigin=anonymous></script>
<script type=text/javascript>var gitalk=new Gitalk({id:'2021-11-26 16:29:46 \u002b0800 \u002b0800',title:'Redis八股文背诵版',clientID:'a76a97e7cc23e0e0b81c',clientSecret:'c2b70fdf4690b743838e85e01d904249470079c8',repo:'notes',owner:'rogeecn',admin:['rogeecn'],body:decodeURI(location.href)});gitalk.render('gitalk-container')</script>
<noscript>Please enable JavaScript to view the <a href=https://github.com/gitalk/gitalk>comments powered by gitalk.</a></noscript>
</div>
</main>
<footer id=footer class=footer>
<div class=social-links>
<a href=https://github.com/rogeecn class="iconfont icon-github" title=github></a>
<a href=http://notes.711xd.com/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a>
</div>
<div class=copyright>
<span class=power-by>
由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动
</span>
<span class=division>|</span>
<span class=theme-info>
主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a>
</span>
<div class=busuanzi-footer>
<span id=busuanzi_container_site_pv> 本站总访问量 <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次 </span>
<span class=division>|</span>
<span id=busuanzi_container_site_uv> 本站总访客数 <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span> 人 </span>
</div>
<span class=copyright-year>
&copy;
2020 -
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>Rogee</span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class="iconfont icon-up"></i>
</div>
</div>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script>
</body>
</html>